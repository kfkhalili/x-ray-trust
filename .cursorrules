# X-Ray Trust - Cursor Rules

## Code Philosophy

### Comments: Why, Not What

- Comments explain **WHY** decisions were made, not **WHAT** the code does
- If code needs explanation of what it does, the code should be clearer
- Focus on reasoning, trade-offs, and design decisions
- Example: "Why async? Next.js 16 made cookies() async..." not "This function is async"

### Type Safety

- **Strict TypeScript**: No `any`, no `unknown`, no type assertions
- Use `readonly` modifiers for immutability
- Prefer type inference where possible, explicit types where needed
- Domain types live in `types/trust.ts`

### Error Handling (Functional Approach)

- **Use neverthrow and Option types** - Eliminate throwing exceptions
- Use `Result<T, E>` from neverthrow for error handling
- Use `Option<T>` for nullable values instead of `null` or `undefined`
- Never use `throw` or `try/catch` - handle errors functionally
- Example: `Result.ok(value)` or `Result.err(error)` instead of throwing
- Example: `Option.some(value)` or `Option.none()` instead of null checks

### Functional Programming (CORE PRINCIPLE)

- **Functional Programming at every opportunity** - This is not optional, it's the default
- **Eliminate side effects** - Pure functions only. Side effects must be isolated and explicit
- Pure functions for ALL calculations (no side effects)
- Immutable data transformations - Use `readonly` modifiers, never mutate
- Prefer `.map()`, `.filter()`, `.reduce()` over loops
- Trust engine is stateless and testable
- Compose functions, don't nest imperative code

## Next.js 16 Patterns

### Server Components & API Routes

- `cookies()` is now async - always `await` it
- Server-side Supabase client must be async: `await createClient()`
- API routes need `export const dynamic = 'force-dynamic'` to prevent build-time analysis
- Use `@supabase/ssr` for cookie-based auth

### Client Components

- Mark with `"use client"` directive
- Use `createClient()` from `@/lib/supabase/client` for browser-side operations
- SessionStorage + URL params for state persistence (see `app/page.tsx`)

## Supabase Patterns

### Client Selection

- **Server-side**: `@/lib/supabase/server` - async, handles cookies automatically
- **Client-side**: `@/lib/supabase/client` - browser, cookie-based auth
- **Admin/Webhooks**: `@/lib/supabase/admin` - bypasses RLS, service role key only

### Row Level Security (RLS)

- Always use RLS for user-facing queries
- Admin client ONLY for webhooks and server-to-server operations
- Never expose service role key to client

## Stripe Integration

### Checkout Flow

- Store `userId` and `credits` in checkout session metadata
- Webhook handler extracts metadata to grant credits
- Always verify webhook signatures before processing

### Credit Packs

- Configure in `lib/stripe.ts` using `Map<string, number>` (Price ID → Credits)
- Empty by default - must be populated with actual Stripe Price IDs

## Trust Engine

### Scoring Algorithm

- 5 signals: Age (25%), Ratio (25%), Activity (25%), Engagement (15%), Listed (10%)
- Automated accounts get score cap of 15 (DANGER verdict)
- Missing data defaults to neutral (50) with reduced confidence
- All scoring functions are pure and testable

### Data Flow

- `XRawData` from twitterapi.io → `calculateTrust()` → `TrustReport`
- User info passed via `_userInfo` internal field
- Breakdown, confidence, and positive indicators included in report

## Testing

### Unit Tests

- Jest configured for TypeScript and Next.js
- Tests in `lib/__tests__/`
- Focus on trust engine logic and utility functions
- Run with `npm test`

## Project Structure

### Key Files

- `lib/trust-engine.ts` - Core scoring logic (pure functions)
- `types/trust.ts` - Domain model types
- `app/api/verify/route.ts` - Main verification endpoint
- `app/api/webhook/route.ts` - Stripe webhook handler
- `components/TrustResults.tsx` - Results display with progressive disclosure

### Scripts

- `scripts/add-credits.ts` - Dev utility to add credits to users
- Excluded from TypeScript compilation (see `tsconfig.json`)

## Environment Variables

### Required

- `NEXT_PUBLIC_SUPABASE_URL` - Supabase project URL
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Public Supabase key
- `SUPABASE_SERVICE_ROLE_KEY` - Admin operations (webhooks)
- `TWITTER_API_KEY` - twitterapi.io API key
- `STRIPE_SECRET_KEY` - Stripe server key
- `STRIPE_WEBHOOK_SECRET` - Stripe webhook signing secret
- `NEXT_PUBLIC_APP_URL` - App URL for redirects

### Local Development

- Use `.env.local` (gitignored)
- Copy from `.env.example` for reference
- Local Supabase: `npx supabase start` (requires Docker)
- Local Stripe webhooks: `stripe listen --forward-to localhost:3000/api/webhook`

## UI/UX Patterns

### Progressive Disclosure

- Score first (immediate answer)
- Breakdown second (understand why)
- Positive indicators third (build confidence)
- Risk flags last (what to watch for)

### State Persistence

- URL params (`?q=username`) for shareable links
- SessionStorage for instant restoration on refresh
- Both used together in `app/page.tsx`

## AI Agent Context

### Operating Mode

- Running in **auto agent mode** in Cursor IDE
- Can browse web, search docs, test UI via browser automation
- Has access to codebase search, file operations, terminal commands
- Works best with clear direction and context

## Common Pitfalls

### Avoid

- Using `any` or `unknown` types
- Mutating data structures (use `readonly`)
- Throwing exceptions (use `Result`/`Option` from neverthrow)
- Side effects in pure functions
- Forgetting `await` on async Supabase clients
- Exposing service role key
- Processing webhooks without signature verification
- Charging credits before successful verification
- Imperative code when functional would work

### Remember

- **Functional Programming is the default** - Not a suggestion, a requirement
- **Eliminate side effects** - Isolate them, make them explicit
- **Use neverthrow** - `Result<T, E>` for errors, `Option<T>` for nullable values
- Credit deduction happens AFTER successful verification
- Webhooks need admin client (no user session)
- API routes need `dynamic = 'force-dynamic'`
- Comments explain why, not what
- Compose functions, avoid imperative nesting

## Architectural Review Learnings

### Client Creation Functions Must Return Result Types

**Critical Rule:** All client creation functions MUST return `Result<T, Error>`, never throw exceptions.

**Why?** Throwing exceptions violates functional programming principles. Errors should be part of the type system, not control flow.

**Pattern:**

```typescript
// ✅ CORRECT: Returns Result
export const createClient = async (): Promise<
  Result<SupabaseClient, Error>
> => {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  if (!url) {
    return err(new Error("NEXT_PUBLIC_SUPABASE_URL must be set"));
  }
  const client = createServerClient(/* ... */);
  return ok(client);
};

// ❌ WRONG: Throws exception
export const createClient = async () => {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  if (!url) {
    throw new Error("NEXT_PUBLIC_SUPABASE_URL must be set"); // NEVER DO THIS
  }
  return createServerClient(/* ... */);
};
```

**Usage in API Routes:**

```typescript
const clientResult = await createClient();
if (clientResult.isErr()) {
  return NextResponse.json(
    { error: "Server configuration error", code: "SERVER_ERROR" },
    { status: 500 }
  );
}
const supabase = clientResult.value;
// Type system guarantees supabase is valid here
```

**Usage in Components:**

```typescript
const clientResult = createClient();
if (clientResult.isErr()) {
  console.error("Failed to create Supabase client:", clientResult.error);
  // In development, this should never happen - fail fast
  throw clientResult.error;
}
const supabase = clientResult.value;
```

**Files to Apply This Pattern:**

- `lib/supabase/server.ts` ✅ (already fixed)
- `lib/supabase/client.ts` ✅ (already fixed)
- `lib/stripe.ts` ✅ (already fixed)
- Any new client creation functions

### Type Guards, Not Type Assertions

**Critical Rule:** Never use type assertions `(data as Type)`. Always use type guards `(data: unknown): data is Type`.

**Why?** Type assertions bypass type checking. Type guards provide runtime validation AND type narrowing.

**Pattern:**

```typescript
// ✅ CORRECT: Type guard with runtime validation
export const isUsernameRequest = (
  data: unknown
): data is { username: string } => {
  return (
    typeof data === "object" &&
    data !== null &&
    "username" in data &&
    typeof (data as { username: unknown }).username === "string"
  );
};

if (!isUsernameRequest(body)) {
  return error;
}
// Type system now knows body.username is string
const username = body.username; // ✅ Type-safe

// ❌ WRONG: Type assertion (no runtime validation)
if (typeof body === "object" && body !== null && "username" in body) {
  const username = (body as { username: string }).username; // ❌ Unsafe
}
```

**Where to Use:**

- API route request body validation
- JSON parsing and validation
- Any place where you need to narrow `unknown` types

**Files with Type Guards:**

- `lib/validation.ts` - Contains `isUsernameRequest()`, `isCreditsRequest()`, etc.
- Use these in API routes instead of inline assertions

### Zero `any` Types Policy

**Critical Rule:** Never use `any` type. Always use proper types or `unknown` with type guards.

**Why?** `any` disables TypeScript's type checking, defeating the purpose of using TypeScript.

**Pattern:**

```typescript
// ✅ CORRECT: Proper type
import type { User } from "@supabase/supabase-js";
const [user, setUser] = useState<User | null>(null);

// ❌ WRONG: any type
const [user, setUser] = useState<any>(null);
```

**Common Fixes:**

- Supabase `User` type: `import type { User } from '@supabase/supabase-js'`
- Component props: Use proper interface types
- API responses: Use type guards to validate and narrow types

### Result Type Composition

**Pattern:** When working with multiple Result types, compose them functionally.

```typescript
// ✅ CORRECT: Compose Results functionally
const clientResult = await createClient();
if (clientResult.isErr()) {
  return err(clientResult.error);
}

const dataResult = await fetchData(clientResult.value);
if (dataResult.isErr()) {
  return err(dataResult.error);
}

return ok(dataResult.value);

// Better: Use Result.andThen() for composition
const result = await pipe(
  createClient(),
  Result.andThen((client) => fetchData(client)),
  Result.map((data) => processData(data))
);
```

### Helper Functions Must Handle Results

**Pattern:** When creating helper functions that use clients, handle Result types internally.

```typescript
// ✅ CORRECT: Helper handles Result internally
const deductCredit = async (userId: string): Promise<Result<void, Error>> => {
  const supabaseResult = await createClient();
  if (supabaseResult.isErr()) {
    return err(supabaseResult.error);
  }
  const supabase = supabaseResult.value;
  // ... use supabase
};

// ❌ WRONG: Helper throws or expects caller to handle client creation
const deductCredit = async (userId: string, supabase: SupabaseClient) => {
  // This forces callers to handle client creation
};
```

### Type Safety in React Components

**Pattern:** When passing props between components, ensure type compatibility.

```typescript
// Component expects: user?: User (User | undefined)
interface CreditModalProps {
  user?: User;
}

// State is: User | null
const [user, setUser] = useState<User | null>(null);

// ✅ CORRECT: Convert null to undefined
<CreditModal user={user ?? undefined} />

// ❌ WRONG: Direct assignment (type mismatch)
<CreditModal user={user} /> // Error: User | null is not assignable to User | undefined
```

## Git Workflow

- Never commit `.env.local` (contains secrets)
- Always commit `.env.example` (placeholder values)
- Run `npm run build` before committing
- Ensure tests pass: `npm test`
